use eth_types::{Field, LIMB_BITS};
use halo2_base::{
    gates::GateInstructions, halo2_proofs::halo2curves::bn256, halo2_proofs::plonk::Error,
    poseidon::hasher::PoseidonSponge, AssignedValue, Context, QuantumCell,
};
use halo2_ecc::{bigint::ProperCrtUint, bls12_381::FpChip, fields::FieldChip};
use halo2curves::{
    bls12_381::{self, Fq},
    group::UncompressedEncoding,
};
use itertools::Itertools;
use pse_poseidon::Poseidon as PoseidonNative;

// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
// And rounded up to nearest integer that divides by t
const N_ROUNDS_PC: [usize; 16] = [
    56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68,
];

// Empirically chosen to take the least space in circuit.
const POSEIDON_SIZE: usize = 11;
const T: usize = POSEIDON_SIZE + 1;
const R_P: usize = N_ROUNDS_PC[T - 2];
const R_F: usize = 8;

/// Generates Poseidon hash commitment to a list of BLS12-381 Fq elements.
/// 
/// Fields elements are initially represented as `NUM_LIMBS` limbs of `LIMB_BITS` bits each.
/// By composing element two limbs in one, we reduce the number of inputs to Poseidon in half.
/// 
/// Each Poseidon sponge absorbs `POSEIDON_SIZE`-2 elements and previos sponge output if it's not the first batch, ie. onion commitment.
/// 
/// Assumes that LIMB_BITS * 2 < 254 (BN254).
pub fn fq_array_poseidon<'a, F: Field>(
    ctx: &mut Context<F>,
    fp_chip: &FpChip<F>,
    fields: impl IntoIterator<Item = &'a ProperCrtUint<F>>,
) -> Result<AssignedValue<F>, Error> {
    let gate = fp_chip.gate();
    let limbs_bases = fp_chip.limb_bases[..2]
        .iter()
        .map(|c| QuantumCell::Constant(*c))
        .collect_vec();

    let limbs = fields
        .into_iter()
        .flat_map(|f| {
            // Fold 4 limbs into 2 to reduce number of posedidon inputs in half.
            f.limbs()
                .chunks(2)
                .map(|limbs| gate.inner_product(ctx, limbs.to_vec(), limbs_bases.clone()))
                .collect_vec()
        })
        .collect_vec();

    let mut poseidon = PoseidonSponge::<F, T, POSEIDON_SIZE>::new::<R_F, R_P, 0>(ctx);

    let mut current_poseidon_hash = None;

    for (i, chunk) in limbs.chunks(POSEIDON_SIZE - 2).enumerate() {
        poseidon.update(chunk);
        if i != 0 {
            poseidon.update(&[current_poseidon_hash.unwrap()]);
        }
        let _ = current_poseidon_hash.insert(poseidon.squeeze(ctx, gate));
    }

    Ok(current_poseidon_hash.unwrap())
}

/// Generates Poseidon hash commitment to a list of BLS12-381 Fq elements.
/// 
/// This is the off-circuit analog of `fq_array_poseidon`.
pub fn poseidon_hash_fq_array<F: Field>(elems: impl Iterator<Item = Fq>, limb_bits: usize) -> F {
    let limbs = elems
        // Converts Fq elements to Fr limbs.
        .flat_map(|x| {
            x.to_bytes_le()
                .chunks((limb_bits / 8) * 2)
                .map(F::from_bytes_le)
                .collect_vec()
        })
        .collect_vec();
    let mut poseidon = PoseidonNative::<F, T, POSEIDON_SIZE>::new(R_F, R_P);
    let mut current_poseidon_hash = None;

    for (i, chunk) in limbs.chunks(POSEIDON_SIZE - 2).enumerate() {
        poseidon.update(chunk);
        if i != 0 {
            poseidon.update(&[current_poseidon_hash.unwrap()]);
        }
        let _ = current_poseidon_hash.insert(poseidon.squeeze());
    }
    current_poseidon_hash.unwrap()
}

/// Wrapper on `poseidon_hash_fq_array` taking pubkeys encoded as uncompressed bytes.
pub fn poseidon_committee_commitment_from_uncompressed(
    pubkeys_uncompressed: &[Vec<u8>],
) -> bn256::Fr {
    let pubkey_affines = pubkeys_uncompressed
        .iter()
        .cloned()
        .map(|bytes| {
            halo2curves::bls12_381::G1Affine::from_uncompressed_unchecked(
                &bytes.as_slice().try_into().unwrap(),
            )
            .unwrap()
        })
        .collect_vec();

    poseidon_hash_fq_array::<bn256::Fr>(pubkey_affines.iter().map(|p| p.x), LIMB_BITS)
}

/// Wrapper on `poseidon_hash_fq_array` taking pubkeys encoded as compressed bytes.
pub fn poseidon_committee_commitment_from_compressed(pubkeys_compressed: &[Vec<u8>]) -> bn256::Fr {
    let pubkeys_x = pubkeys_compressed.iter().cloned().map(|mut bytes| {
        bytes[0] &= 0b00011111;
        bls12_381::Fq::from_bytes_be(&bytes.try_into().unwrap())
            .expect("bad bls12_381::Fq encoding")
    });
    poseidon_hash_fq_array::<bn256::Fr>(pubkeys_x, LIMB_BITS)
}
